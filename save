/* parse .data arguments */
boolean parseData(char *restOfLine)
{
    int argc, argLen;
    char *temp;

 	enum
	{
		waitForArg,		   /* Waiting for arg. */
		readArg,		   /* Right now reads an arg  */
		waitForSep		   /* Wait for the 'specific' separator */
	} status = waitForArg; /* An status that will help with the parse */

	int i,		/* loop helper */
		startI; /* The beginning of the current arg */

    if(!restOfLine) /* missing data */
    {
        numOfErrors++;
        if(!strcmp(pSpLine -> cmd, DIR_DATA))
            printError(MISSING_DATA);
        else    
            printError(MISSING_OPERAND);
        return false;
    }

	argc = 0;
    argLen = 0;

	for (i = 0; restOfLine[i]; i++) /* Run on the line, char by char */
	{
		if (status == waitForArg) /* Waiting for the start of an arg. */
		{
			if (isspace(restOfLine[i])) /* Before arg can be white-spaces */
				continue;

			if (restOfLine[i] == COMMA) /* There is no arg */
			{
				printf("Illegal SEPARATOR. \n");
				return false;
			}
			else /* The start of the arg */
			{
				startI = i;
				status = readArg;
			}
		}
		else if (status == readArg) /* Read an arg. */
		{
			if (isspace(restOfLine[i]) || restOfLine[i] == COMMA) /* Space / Separator marks the end of the arg */
			{
				/* copy the arg to an allocated "string" */
				argLen = i - startI;
                temp = (char *)	safeAlloc(sCalloc,(argLen + 1), sizeof(char));																  /* i is the place in the line where the arg ends. */
				temp = strncpy(temp, restOfLine + startI, argLen); /* +1 for the null-terminator */
				temp[argLen] = '\0';																  /* Adds the null terminator to the end of the line. */
                if(!addArgToArgList(temp))
                {
                    free(temp);
                    return false;
                }
                else
                {
                printf("THIS IS THE ARG: %s\n", pSpLine -> argsHead -> name); /* debug */
                 }
                argLen = 0;
				++argc;
                free(temp);

				status = waitForSep;
				if (restOfLine[i] == COMMA) /* There is separator, now need another arg. */
					status = waitForArg;
			}
			else /* Still reads the line */
				continue;
		}
		else if (status == waitForSep) /* Waiting for separator */
		{
			if (isspace(restOfLine[i])) /* Before separator can be white-spaces */
				continue;
			if (restOfLine[i] == COMMA) /* Find the separator, now need another arg */
				status = waitForArg;
			else /* There is an arg before separator! */
			{
				printf("Missing SEPARATOR! \n");
				return false;
			}
		}
	}

	if (status == waitForArg) /* There is a separator at the end of the line */
	{
		printf("Illegal SEPARATOR. \n");
		return false;
	}

	else if (status == readArg) /* There is arg at the end of the line */
    {
        /* copy the arg to an allocated "string" */
        argLen = i - startI;
        temp = (char *)	safeAlloc(sCalloc, (argLen + 1), sizeof(char));																  /* i is the place in the line where the arg ends. */
        temp = strncpy(temp, restOfLine + startI, argLen); /* +1 for the null-terminator */
        temp[argLen] = '\0';																  /* Adds the null terminator to the end of the line. */
        if(!addArgToArgList(temp))
        {
            free(temp);
            return false;
        }
        else{
        printf("THIS IS THE ARG: %s\n", pSpLine -> argsHead -> name); /* debug */
        }
        argLen = 0;
        ++argc;
        free(temp);
    }

	else if (argc == 0) /* line wasnt empty, but had white chars and no args -> missing  */
    {
        numOfErrors++;
        if(!strcmp(pSpLine -> cmd, DIR_DATA))
            printError(MISSING_DATA);
        else    
            printError(MISSING_OPERAND);
        return false;
    }

	return true;
}